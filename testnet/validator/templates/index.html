<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Mock Validator</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0f172a;
      --card: #111c35;
      --border: #1e293b;
      --accent: #38bdf8;
      --accent-hover: #0ea5e9;
      --text: #e2e8f0;
      --muted: #94a3b8;
      --error: #f87171;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top, rgba(56,189,248,0.06), transparent),
                  radial-gradient(circle at bottom, rgba(99,102,241,0.05), transparent),
                  var(--bg);
      color: var(--text);
      font-family: "Fira Code", "JetBrains Mono", Menlo, monospace;
      display: flex;
      justify-content: center;
      padding: 3rem 1.5rem;
    }
    main {
      width: 100%;
      max-width: 960px;
      display: grid;
      gap: 1.5rem;
    }
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1.5rem;
      box-shadow: 0 18px 40px rgba(15,23,42,0.35);
    }
    h1 {
      margin: 0;
      font-size: 1.8rem;
      letter-spacing: 2px;
      text-transform: uppercase;
      color: var(--accent);
    }
    .status-grid {
      display: grid;
      gap: 0.5rem;
      font-size: 0.95rem;
    }
    .status-line strong { color: var(--muted); }
    .status-line.error { color: var(--error); }

    .executor-list {
      display: grid;
      gap: 1rem;
    }
    .executor-card {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 1rem;
      background: rgba(17,28,53,0.85);
      display: grid;
      gap: 0.75rem;
    }
    .executor-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
    }
    .executor-meta {
      display: grid;
      gap: 0.25rem;
      font-size: 0.9rem;
    }
    .executor-actions {
      display: flex;
      gap: 0.75rem;
    }
    button.primary {
      padding: 0.45rem 1.1rem;
      background: var(--accent);
      border: none;
      border-radius: 999px;
      color: #0f172a;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
    }
    button.primary:hover { background: var(--accent-hover); transform: translateY(-1px); }
    button.primary:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
    button.outline {
      padding: 0.45rem 1.1rem;
      background: transparent;
      border: 1px solid var(--accent);
      border-radius: 999px;
      color: var(--accent);
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease, color 0.2s ease;
    }
    button.outline:hover { background: rgba(56,189,248,0.12); color: var(--text); transform: translateY(-1px); }
    button.outline:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

    .executor-verification {
      font-size: 0.85rem;
      color: var(--muted);
      display: grid;
      gap: 0.25rem;
    }
    .executor-verification strong {
      color: var(--text);
    }
    .verification-status-badge {
      display: inline-block;
      padding: 0.15rem 0.6rem;
      border-radius: 999px;
      font-size: 0.75rem;
      font-weight: 600;
      background: rgba(56,189,248,0.12);
      color: var(--accent);
    }
    .verification-status-badge.error {
      background: rgba(248,113,113,0.12);
      color: var(--error);
    }
    .verification-timestamp {
      font-size: 0.8rem;
      color: var(--muted);
    }
    .verification-error {
      color: var(--error);
      font-size: 0.85rem;
    }

    .terminal {
      background: #050816;
      border: 1px solid #1f2937;
      border-radius: 14px;
      overflow: hidden;
      display: grid;
      grid-template-rows: auto 1fr auto;
      height: 420px;
    }
    .terminal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      background: #0b1120;
      border-bottom: 1px solid #1f2937;
    }
    .terminal-status { color: var(--muted); font-size: 0.9rem; }
    .terminal-output {
      padding: 1rem;
      overflow-y: auto;
      font-family: "Fira Code", monospace;
      font-size: 0.9rem;
      background: #050816;
      line-height: 1.45;
      white-space: pre-wrap;
      scrollbar-width: thin;
      scrollbar-color: var(--accent) rgba(15,23,42,0.65);
    }
    .terminal-output::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    .terminal-output::-webkit-scrollbar-track {
      background: #0b1120;
    }
    .terminal-output::-webkit-scrollbar-thumb {
      background: #1f2937;
      border-radius: 999px;
    }
    .terminal-output:hover::-webkit-scrollbar-thumb {
      background: var(--accent);
    }
    .terminal-input {
      border: none;
      border-top: 1px solid #1f2937;
      padding: 0.85rem 1rem;
      background: #0b1120;
      color: var(--text);
      font-family: inherit;
      font-size: 0.95rem;
    }
    .terminal-input:disabled { opacity: 0.6; }
    .terminal-input:focus { outline: none; }
    button.secondary {
      background: transparent;
      border: 1px solid #1f2937;
      color: var(--muted);
      border-radius: 999px;
      padding: 0.35rem 1rem;
      cursor: pointer;
    }
    button.secondary:hover { border-color: var(--accent); color: var(--accent); }
    .empty-state {
      text-align: center;
      color: var(--muted);
      padding: 1rem;
      border: 1px dashed var(--border);
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <main>
    <section class="card">
      <h1>Mock Lium Validator</h1>
      <p style="margin-top:0.35rem; color: var(--muted);">Request SSH access, then open an interactive shell within your web browser.</p>
      <div class="status-grid">
        <div class="status-line"><strong>Status:</strong> <span id="status-state">idle</span></div>
        <div class="status-line"><strong>Message:</strong> <span id="status-message">Ready</span></div>
        <div class="status-line error"><strong>Last error:</strong> <span id="status-error">-</span></div>
      </div>
      <div style="margin-top:1rem;">
        <button class="primary" id="request-ssh">Request SSH Access</button>
      </div>
    </section>

    <section class="card">
      <h2 style="margin-top:0; font-size:1.1rem; letter-spacing:1px; text-transform:uppercase;">Available Executors</h2>
      <div id="executor-list" class="executor-list">
        <div class="empty-state">No executors yet. Request SSH access to populate this list.</div>
      </div>
    </section>

    <section class="terminal">
      <div class="terminal-header">
        <span class="terminal-status" id="terminal-status">Terminal idle</span>
        <div class="executor-actions">
          <button class="secondary" id="clear-terminal">Clear</button>
        </div>
      </div>
      <div class="terminal-output" id="terminal-output"></div>
      <input class="terminal-input" id="terminal-input" placeholder="Select an executor to start a session" disabled />
    </section>
  </main>

  <script type="application/json" id="initial-state">__STATE_JSON__</script>
  <script>
    const stateBox = document.getElementById('status-state');
    const messageBox = document.getElementById('status-message');
    const errorBox = document.getElementById('status-error');
    const executorList = document.getElementById('executor-list');
    const terminalOutput = document.getElementById('terminal-output');
    const terminalInput = document.getElementById('terminal-input');
    const terminalStatus = document.getElementById('terminal-status');
    const clearButton = document.getElementById('clear-terminal');
    const requestButton = document.getElementById('request-ssh');

    const ANSI_COLOR_MAP = {
      30: '#1f2937',
      31: '#f87171',
      32: '#4ade80',
      33: '#facc15',
      34: '#60a5fa',
      35: '#c084fc',
      36: '#38bdf8',
      37: '#e2e8f0',
      90: '#94a3b8',
      91: '#fca5a5',
      92: '#86efac',
      93: '#fde68a',
      94: '#93c5fd',
      95: '#f5d0fe',
      96: '#bae6fd',
      97: '#f8fafc',
    };

    const ANSI_BG_COLOR_MAP = {
      40: '#111827',
      41: '#431724',
      42: '#064e3b',
      43: '#854d0e',
      44: '#1d4ed8',
      45: '#6b21a8',
      46: '#0f766e',
      47: '#e5e7eb',
      100: '#1f2937',
      101: '#b91c1c',
      102: '#15803d',
      103: '#b45309',
      104: '#1d4ed8',
      105: '#7e22ce',
      106: '#0f766e',
      107: '#f3f4f6',
    };

    const formatTimestamp = (value) => {
      if (!value) return null;
      const numeric = typeof value === 'number' ? value : Number(value);
      if (Number.isNaN(numeric)) return null;
      return new Date(numeric * 1000).toLocaleString();
    };

    const ANSI16_COLORS = [
      '#000000',
      '#aa0000',
      '#00aa00',
      '#aa5500',
      '#0000aa',
      '#aa00aa',
      '#00aaaa',
      '#aaaaaa',
      '#555555',
      '#ff5555',
      '#55ff55',
      '#ffff55',
      '#5555ff',
      '#ff55ff',
      '#55ffff',
      '#ffffff',
    ];

    const escapeHtml = (value) =>
      value
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');

    const rgbToHex = (r, g, b) =>
      `#${[r, g, b].map((component) => component.toString(16).padStart(2, '0')).join('')}`;

    const ansi256ToHex = (code) => {
      if (Number.isNaN(code) || code < 0) {
        return null;
      }
      if (code <= 15) {
        return ANSI16_COLORS[code];
      }
      if (code >= 16 && code <= 231) {
        const idx = code - 16;
        const r = Math.floor(idx / 36);
        const g = Math.floor((idx % 36) / 6);
        const b = idx % 6;
        const convert = (value) => (value === 0 ? 0 : value * 40 + 55);
        return rgbToHex(convert(r), convert(g), convert(b));
      }
      if (code >= 232 && code <= 255) {
        const shade = (code - 232) * 10 + 8;
        return rgbToHex(shade, shade, shade);
      }
      return null;
    };

    const styleFromState = (state) => {
      const styles = [];
      if (state.fg) styles.push(`color: ${state.fg}`);
      if (state.bg) styles.push(`background-color: ${state.bg}`);
      if (state.bold) styles.push('font-weight: 600');
      if (state.italic) styles.push('font-style: italic');
      if (state.underline) styles.push('text-decoration: underline');
      return styles.join('; ');
    };

    const applyAnsiCodes = (state, codes) => {
      for (let i = 0; i < codes.length; i += 1) {
        const code = codes[i];
        if (Number.isNaN(code)) continue;

        if (code === 0) {
          state.fg = null;
          state.bg = null;
          state.bold = false;
          state.italic = false;
          state.underline = false;
          continue;
        }
        if (code === 1) {
          state.bold = true;
          continue;
        }
        if (code === 3) {
          state.italic = true;
          continue;
        }
        if (code === 4) {
          state.underline = true;
          continue;
        }
        if (code === 22) {
          state.bold = false;
          continue;
        }
        if (code === 23) {
          state.italic = false;
          continue;
        }
        if (code === 24) {
          state.underline = false;
          continue;
        }
        if (code === 39) {
          state.fg = null;
          continue;
        }
        if (code === 49) {
          state.bg = null;
          continue;
        }
        if (code >= 30 && code <= 37) {
          state.fg = ANSI_COLOR_MAP[code] || state.fg;
          continue;
        }
        if (code >= 90 && code <= 97) {
          state.fg = ANSI_COLOR_MAP[code] || state.fg;
          continue;
        }
        if (code >= 40 && code <= 47) {
          state.bg = ANSI_BG_COLOR_MAP[code] || state.bg;
          continue;
        }
        if (code >= 100 && code <= 107) {
          state.bg = ANSI_BG_COLOR_MAP[code] || state.bg;
          continue;
        }
        if (code === 38 || code === 48) {
          const mode = codes[i + 1];
          if (mode === 5 && typeof codes[i + 2] === 'number') {
            const hex = ansi256ToHex(codes[i + 2]);
            if (hex) {
              if (code === 38) state.fg = hex;
              else state.bg = hex;
            }
            i += 2;
            continue;
          }
          if (mode === 2 && typeof codes[i + 2] === 'number') {
            const r = codes[i + 2];
            const g = codes[i + 3];
            const b = codes[i + 4];
            if (
              typeof r === 'number' &&
              typeof g === 'number' &&
              typeof b === 'number'
            ) {
              const hex = rgbToHex(r, g, b);
              if (code === 38) state.fg = hex;
              else state.bg = hex;
            }
            i += 4;
            continue;
          }
        }
      }
    };

    const ansiToHtml = (input) => {
      if (!input) return '';

      const sanitized = input
        .replace(/\u001b\][^\u0007]*\u0007/g, '')
        .replace(/\r\n/g, '\n')
        .replace(/\r/g, '\n')
        .replace(/\u0007/g, '')
        .replace(/\u001b\[[0-9;?]*[A-Za-z]/g, (seq) =>
          seq.endsWith('m') ? seq : ''
        );

      const ansiRegex = /\u001b\[([0-9;]*)m/g;
      const state = {
        fg: null,
        bg: null,
        bold: false,
        italic: false,
        underline: false,
      };

      let result = '';
      let lastIndex = 0;
      let currentStyle = '';
      let match;

      const flushText = (segment) => {
        if (!segment) return;
        result += escapeHtml(segment).replace(/\n/g, '<br>');
      };

      while ((match = ansiRegex.exec(sanitized)) !== null) {
        flushText(sanitized.slice(lastIndex, match.index));
        const codes = match[1]
          .split(';')
          .filter((entry) => entry.length > 0)
          .map((entry) => Number(entry));
        if (codes.length === 0) codes.push(0);

        applyAnsiCodes(state, codes);

        const nextStyle = styleFromState(state);
        if (nextStyle !== currentStyle) {
          if (currentStyle) result += '</span>';
          if (nextStyle) result += `<span style="${nextStyle}">`;
          currentStyle = nextStyle;
        }
        lastIndex = ansiRegex.lastIndex;
      }

      flushText(sanitized.slice(lastIndex));
      if (currentStyle) result += '</span>';
      return result;
    };

    let latestState = null;
    let terminalSocket = null;
    let activeExecutorId = null;

    const appendOutput = (text) => {
      const html = ansiToHtml(text);
      if (!html) return;
      terminalOutput.insertAdjacentHTML('beforeend', html);
      terminalOutput.scrollTop = terminalOutput.scrollHeight;
    };

    const closeTerminal = (message) => {
      if (terminalSocket) {
        terminalSocket.close();
        terminalSocket = null;
      }
      if (message) appendOutput(`\n${message}\n`);
      terminalInput.value = '';
      terminalInput.disabled = true;
      terminalInput.placeholder = 'Select an executor to start a session';
      terminalStatus.textContent = 'Terminal idle';
      activeExecutorId = null;
    };

    const openTerminal = (executor) => {
      if (!executor) return;
      if (!latestState || !latestState.executors) {
        alert('No executor information available');
        return;
      }

      if (terminalSocket) {
        closeTerminal('\n[Session switched]\n');
      }

      const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
      const ws = new WebSocket(`${protocol}://${window.location.host}/ws/ssh/${encodeURIComponent(executor.uuid)}`);

      terminalStatus.textContent = `Connecting to ${executor.address}:${executor.ssh_port || executor.port}`;
      terminalInput.value = '';
      terminalInput.disabled = true;
      activeExecutorId = executor.uuid;

      ws.addEventListener('open', () => {
        terminalSocket = ws;
        terminalStatus.textContent = `Session with ${executor.address}`;
        appendOutput(`\n[Connected to ${executor.address}]\n`);
        terminalInput.disabled = false;
        terminalInput.placeholder = 'Type a command and press Enter';
        terminalInput.focus();
      });

      ws.addEventListener('message', (event) => {
        appendOutput(event.data);
      });

      ws.addEventListener('close', () => {
        if (terminalSocket === ws) {
          appendOutput('\n[Session closed]\n');
          terminalSocket = null;
          terminalInput.disabled = true;
          terminalInput.placeholder = 'Select an executor to start a session';
          terminalStatus.textContent = 'Terminal idle';
          activeExecutorId = null;
        }
      });

      ws.addEventListener('error', () => {
        appendOutput('\n[Connection error]\n');
      });
    };

    clearButton.addEventListener('click', () => {
      terminalOutput.innerHTML = '';
    });

    terminalInput.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        if (!terminalSocket) return;
        const value = terminalInput.value;
        terminalSocket.send(value.endsWith('\n') ? value : `${value}\n`);
        terminalInput.value = '';
      }
    });

    window.addEventListener('beforeunload', () => {
      if (terminalSocket) {
        terminalSocket.close();
      }
    });

    const verifyExecutor = async (executor, triggerButton) => {
      if (!executor) return;
      const button = triggerButton;
      const originalLabel = button.textContent;

      try {
        button.disabled = true;
        button.textContent = 'Verifying...';

        const response = await fetch('/verify_quote', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ executor_id: executor.uuid }),
        });

        const payload = await response.json().catch(() => ({}));
        if (!response.ok) {
          const message = (payload && payload.detail) || 'Verification failed';
          alert(message);
          return;
        }

        if (payload.state) {
          render(payload.state);
        }
        if (payload.verification) {
          console.info('Quote verification result:', payload.verification);
        }
      } catch (err) {
        const message = err && err.message ? err.message : 'Verification request failed';
        alert(message);
      } finally {
        button.disabled = false;
        button.textContent = originalLabel;
      }
    };

    const renderExecutors = (executors) => {
      executorList.innerHTML = '';
      if (!executors || executors.length === 0) {
        executorList.innerHTML = '<div class="empty-state">No executors yet. Request SSH access to populate this list.</div>';
        return;
      }

      const activeVerificationId =
        latestState && latestState.verification_status === 'running' && latestState.verification_result
          ? latestState.verification_result.executor_uuid
          : null;

      executors.forEach((executor) => {
        const card = document.createElement('div');
        card.className = 'executor-card';

        const header = document.createElement('div');
        header.className = 'executor-card-header';

        const meta = document.createElement('div');
        meta.className = 'executor-meta';
        meta.innerHTML = `
          <strong>${executor.uuid}</strong>
          <span>RPC: ${executor.address}:${executor.port}</span>
          <span>SSH: ${executor.ssh_username}@${executor.address}:${executor.ssh_port || 22}</span>
        `;

        const actions = document.createElement('div');
        actions.className = 'executor-actions';

        const verifyButton = document.createElement('button');
        verifyButton.className = 'outline';
        verifyButton.type = 'button';
        const isActive = executor.uuid === activeVerificationId;
        verifyButton.textContent = isActive ? 'Verifying...' : 'Verify';
        verifyButton.disabled = Boolean(isActive);
        verifyButton.addEventListener('click', () => verifyExecutor(executor, verifyButton));

        const connectButton = document.createElement('button');
        connectButton.className = 'primary';
        connectButton.textContent = 'Open Terminal';
        connectButton.type = 'button';
        connectButton.addEventListener('click', () => openTerminal(executor));

        actions.appendChild(verifyButton);
        actions.appendChild(connectButton);

        header.appendChild(meta);
        header.appendChild(actions);

        const verificationBlock = document.createElement('div');
        verificationBlock.className = 'executor-verification';
        const verification = executor.verification;

        if (!verification) {
          verificationBlock.textContent = 'Quote not verified yet.';
        } else {
          const statusLine = document.createElement('div');
          const badge = document.createElement('span');
          badge.className = 'verification-status-badge';
          const statusText = (verification.verification_status || (verification.error ? 'error' : 'unknown')).toString();
          if (statusText.toLowerCase() === 'error' || verification.error) {
            badge.classList.add('error');
          }
          badge.textContent = statusText.toUpperCase();
          statusLine.innerHTML = 'Quote status: ';
          statusLine.appendChild(badge);
          verificationBlock.appendChild(statusLine);

          if (verification.error) {
            const errorLine = document.createElement('div');
            errorLine.className = 'verification-error';
            errorLine.textContent = verification.error;
            verificationBlock.appendChild(errorLine);
          }

          if (verification.nonce) {
            const nonceLine = document.createElement('div');
            const noncePreview = typeof verification.nonce === 'string'
              ? `${verification.nonce.slice(0, 8)}...`
              : verification.nonce;
            nonceLine.innerHTML = `<strong>Nonce:</strong> ${noncePreview}`;
            verificationBlock.appendChild(nonceLine);
          }

          const verifiedAt = formatTimestamp(verification.verified_at);
          const requestedAt = formatTimestamp(verification.requested_at);
          if (verifiedAt || requestedAt) {
            const timeLine = document.createElement('div');
            timeLine.className = 'verification-timestamp';
            const parts = [];
            if (verifiedAt) parts.push(`verified ${verifiedAt}`);
            if (requestedAt && requestedAt !== verifiedAt) parts.push(`requested ${requestedAt}`);
            timeLine.textContent = parts.join(' • ');
            verificationBlock.appendChild(timeLine);
          }

          if (Array.isArray(verification.advisory_ids) && verification.advisory_ids.length > 0) {
            const advisoriesLine = document.createElement('div');
            advisoriesLine.innerHTML = `<strong>Advisories:</strong> ${verification.advisory_ids.join(', ')}`;
            verificationBlock.appendChild(advisoriesLine);
          }
        }

        card.appendChild(header);
        card.appendChild(verificationBlock);
        executorList.appendChild(card);
      });
    };

    const render = (state) => {
      latestState = state;
      stateBox.textContent = state.status;
      messageBox.textContent = state.message || '-';
      errorBox.textContent = state.last_error || '-';
      renderExecutors(state.executors || []);

      if (activeExecutorId) {
        const stillExists = state.executors && state.executors.find((ex) => ex.uuid === activeExecutorId);
        if (!stillExists) {
          closeTerminal('\n[Executor no longer available]\n');
        }
      }
    };

    const fetchStatus = async () => {
      try {
        const response = await fetch('/status');
        if (!response.ok) return;
        const data = await response.json();
        render(data);
      } catch (err) {
        console.error('Failed to fetch status', err);
      } finally {
        setTimeout(fetchStatus, 2000);
      }
    };

    if (requestButton) {
      requestButton.addEventListener('click', async () => {
        try {
          requestButton.disabled = true;
          requestButton.textContent = 'Requesting...';
          const response = await fetch('/rent', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({}),
          });
          if (!response.ok) {
            const error = await response.json().catch(() => ({ detail: 'Unknown error' }));
            alert(error.detail || 'Failed to request SSH access');
          } else {
            const data = await response.json();
            render(data);
          }
        } catch (err) {
          alert(err.message || 'Failed to request SSH access');
        } finally {
          requestButton.disabled = false;
          requestButton.textContent = 'Request SSH Access';
        }
      });
    }

    const initialState = JSON.parse(document.getElementById('initial-state').textContent || '{}');
    render(initialState);
    fetchStatus();
  </script>
</body>
</html>
